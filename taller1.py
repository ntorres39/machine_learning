# -*- coding: utf-8 -*-
"""TALLER1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N70qUoZG4b-YLxQDSLedz7xAQCixVA8x

## TALLER 1 (1mer Corte) MACHINE LEARNING

Nicolas Torres Carmona 63182040
Steven Homez 63192030
"""

#1
nombre = "Cristian" ##comandos que va a decir
edad = 23

mensaje_saludo = f"Hola, me llamo {nombre} y tengo {edad} años." ##mensaje y entre parentesis el diccionario
print(mensaje_saludo)

#Hola, me llamo Cristian y tengo 23 años.

#2
import math #Esta línea importa la libreria math, que contiene funciones matemáticas, incluyendo el valor de π.

def main(): #Función principal llamada main, que contendrá el flujo de la función.
    radio = float(input("Ingresa el radio del círculo: ")) #Solicitar al usuario que ingrese el radio del círculo y lo almacena en la variable radio. La función input() recopila la entrada del usuario como texto, y float lo convierte en número decimal (flotante).
    area = math.pi * radio ** 2 #Calcula el área del círculo utilizando la fórmula matemática π * radio al cuadrado.
    print(f"El área del círculo con radio {radio} es: {area:.2f}") #Muestra un mensaje en la consola que incluye el valor del radio y el área calculada del círculo.:.2f Para mostrar dos decimales después del punto decimal.

main() #Se ejecuta la función main().

#Ingresa el radio del círculo: 10
#El área del círculo con radio 10.0 es: 314.16

#3
def calcular_promedio(lista_numeros): ##<-- Defino que va a hacer y la lista
    if not lista_numeros:
        return 0  # Retorna 0 si la lista está vacía para evitar división por cero
    suma_total = sum(lista_numeros) ##<-- suma de la lista
    promedio = suma_total / len(lista_numeros) ##<-- calculo el promedio
    return promedio ##<-- devuelve el promedio
numeros = [15, 27, 8, 36, 12, 45, 6] ##<-- La lista
promedio_resultado = calcular_promedio(numeros) ##<-- comando para calcular la lista
print(f"El promedio es: {promedio_resultado}") ##<-- print

#El promedio es: 21.285714285714285

#4
def num(): #Se inicia la definición de la función principal num().
    numeros = [5,12,8,15,3,10,20,7] #Se asigna el conjunto de numeros
    print("Números mayores que 10:") #Imprime encabezado
    for numero in numeros: #Inicia un bucle for que recorre cada elemento de la lista, asignando el valor de cada elemento a la variable num.
        if numero > 10: #Verifica si es mayor a 10
            print(numero) #Si es mayor, imprime resultados
num() #Uso de la función

#Números mayores que 10:
#12
#15
#20

#5
def obtener_precio_producto(nombre_producto): ##<-- Defino que va a hacer y la lista
    precios_productos = {
        'producto1': 10.99,
        'producto2': 25.50,
        'producto3': 5.75
    } ##<-- biblioteca

    if nombre_producto in precios_productos: ##<-- Condicional a
        precio = precios_productos[nombre_producto]
        print(f"El precio de {nombre_producto} es: ${precio:.2f}")
    else: ##<-- condicional b si no sucede a
        print("Producto no encontrado en la lista")
obtener_precio_producto('producto1') ##<-- aplicacion introduciendo el nombre del producto

#El precio de producto1 es: $10.99

#6
def es_primo(numero): #Definicion de funcion principal con su argumento
    if numero <= 1: #Comprueba si el número es igual o menor a 1. En ese caso, no es primo y retorna False.
        return False
    if numero <= 3: #Comprueba si el número es menor o igual a 3. Estos son primos, por lo que retorna True.
        return True
    if numero % 2 == 0 or numero % 3 == 0: #
        return False
    i = 5 #Inicializa un contador i en 5. Comprobar la divisibilidad del número desde 5 en adelante.
    while i * i <= numero: #Realiza un bucle mientras el cuadrado de i sea menor o igual al número dado. Esto se hace para optimizar el cálculo.
        if numero % i == 0 or numero % (i + 2) == 0: #Comprueba si el número es divisible por i o i + 2. Si es divisible por alguno de estos valores, no es primo y retorna False.
            return False
        i += 6 #Incrementa i en 6 en cada iteración del bucle. Esto es una optimización, ya que evita revisar números pares múltiples veces.

    return True


es_primo(2) #Uso de la función

#True

#7
nombres = ["Juan", "María", "Pedro", "Luis", "Alex", "Ana", "Carlos"] ##<-- La lista
indice = 0
while indice < len(nombres) and nombres[indice] != "Alex": ##<-- Bucle hasta que se repita alex
    print(nombres[indice]) ##<-- que se imprima el primer nombre
    indice += 1 ##<-- el nombre y que vaya al siguiente
    print("Se encontró el nombre 'Alex'.") ##<-- print final ya que se encontro alex ya

#Juan Se encontró el nombre 'Alex'.
#María Se encontró el nombre 'Alex'.
#Pedro Se encontró el nombre 'Alex'.
#Luis Se encontró el nombre 'Alex'.

#8
def invertir_cadena(cadena): #Definicion de funcion principal
    return cadena[::-1] #Obtener la cadena invertida (-1)

cadena_original = "Machine Learning" #Cadena original
cadena_invertida = invertir_cadena(cadena_original) #Uso de la funcion

print("Cadena original:", cadena_original) #Imprime version inicial
print("Cadena invertida:", cadena_invertida) #Imprime cadena invertida

#Cadena original: Machine Learning
#Cadena invertida: gninraeL enihcaM

#9
numeros_pares = [num for num in range(2, 21, 2)] ##<-- Mi rango que es que vaya en intervalos de dos en dos termine en 21 y comience en 2
print(numeros_pares)

#[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

#10
def generar_fibonacci(n): #Funcion principal
    fibonacci = [0, 1] #Crear lista con los dos primeros valores
    while len(fibonacci) < n: #Bucle while mientras la longitud de la lista sea menor que la cantidad n que se desean generar.
        next_term = fibonacci[-1] + fibonacci[-2] #Calcula el siguiente término de la serie sumando los dos últimos de la lista (-1=último elemento, -2=penúltimo).
        fibonacci.append(next_term) #Agrega el siguiente valor a la lista.
    return fibonacci #Devuelve la lista fibonacci de los primeros n valores de la serie.

cantidad_terminos = int(input("Ingrese la cantidad de términos de Fibonacci a generar: ")) #Solicitar al usuario la cantidad de términos a generar. La función int lo convierte en entero.

serie_fibonacci = generar_fibonacci(cantidad_terminos) # Generar la serie de Fibonacci

print("Serie de Fibonacci con", cantidad_terminos, "términos:") # Imprimir la serie generada
for term in serie_fibonacci: #Inicia un bucle for que recorre cada término de serie_fibonacci
    print(term, end=" ") #Imprime cada término de la serie de Fibonacci seguido de un espacio en la misma línea. El argumento end=" " especifica que se debe usar un espacio en lugar del salto de línea después de cada impresión.

#Ingrese la cantidad de términos de Fibonacci a generar: 100
#Serie de Fibonacci con 100 términos:
#0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987

#11
def calcular_interes_simple(principal, tasa_interes, tiempo_años): ##<-- definicion de la ecuacion
    interes = principal * tasa_interes * tiempo_años / 100  ##<-- calculo del interes
    monto_total = principal + interes  ##<-- el monto total que es principal mas el interes
    print(f"El interés simple es: {interes}")
    print(f"El monto total es: {monto_total}")
calcular_interes_simple(principal, tasa_interes, tiempo_anos)  ##<-- Llama la funcion para que funcione

principal = 100000  # Monto principal en dólares
tasa_interes = 5  # Tasa de interés en porcentaje
tiempo_anos = 3   # Tiempo en años

#El interés simple es: 15000.0
#El monto total es: 115000.0

#12
def calcular_promedio_precios(precios): #Definicion de la funcion principal
    total = sum(precios) #Calcula la suma de todos los precios en la lista.
    promedio = total / len(precios) #Calcula el promedio dividiendo la suma total por la cantidad de elementos en la lista.
    return promedio #Devuelve el promedio calculado.

precios_acciones = [100.5, 105.2, 98.7, 110.3, 102.8, 107.0] #Crear una lista de precios de acciones

promedio_precios = calcular_promedio_precios(precios_acciones) #Calcular el promedio de los precios utilizando la función
print("Promedio de precios de acciones:", promedio_precios) #Imprimir el promedio de precios

#Promedio de precios de acciones: 104.08333333333333

#13
def convertir_dolares_a_euros(cantidad_dolares, tasa_cambio):
    cantidad_euros = cantidad_dolares * tasa_cambio  ##<-- Ecuacion para dar con la cantidad de euros
    print(f"{cantidad_dolares} dólares equivalen a {cantidad_euros} euros")  ##<-- lo que va a decir en la salida

cantidad_dolares = 100
tasa_cambio = 0.85  # Tasa de cambio de dólares a euros

convertir_dolares_a_euros(cantidad_dolares, tasa_cambio)  ##<-- llama la funcion para calcular

#100 dólares equivalen a 85.0 euros

#14
def calcular_factorial(numero): #Definicion de la funcion prinicpal
    if numero < 0:
        return "No se puede calcular" #Comprobar si es negativo, si sí, arroja que no puede ser calculado
    if numero == 0 or numero == 1: #Comprobar. El numero fatorial de 0 y 1 = 1, por lo que devuelve el valor 1
        return 1

    factorial = 1 #Iniciar la variable en 1
    for i in range(2, numero + 1): #Bucle que comienza en 2 y termina en el número dado + 1.
        factorial *= i #Multiplica la variable factorial por cada valor i en el bucle.

    return factorial #Devuelve el valor calculado del factorial

numero = int(input("Ingrese un número para calcular su factorial: ")) #Solicitar al usuario ingresar un número

factorial_calculado = calcular_factorial(numero) #Calcular el factorial utilizando la función

print("El factorial de", numero, "es:", factorial_calculado) #Imprimir el resultado

#Ingrese un número para calcular su factorial: -5
#El factorial de -5 es: No se puede calcular

#15
cuentas_bancarias = {
    'Juan Perez': 5000,
    'Maria Garcia': 7500,
    'Luis Martinez': 12000,
    'Ana Sanchez': 9500,
    'Pedro Rodriguez': 11000
}  ##<-- bibloteca

def cuenta_con_saldo_mas_alto(cuentas_bancarias):
    max_saldo = float('-inf')  ##es necesario numeros con float ya que se acercan a inf
    cuenta_max = None
    for cuenta, saldo in cuentas_bancarias.items():
        if saldo > max_saldo:
            max_saldo = saldo
            cuenta_max = cuenta
    return cuenta_max, max_saldo

cuenta_maxima, saldo_maximo = cuenta_con_saldo_mas_alto(cuentas_bancarias)
print(f"La cuenta con el saldo más alto es '{cuenta_maxima}' con un saldo de ${saldo_maximo}")

#La cuenta con el saldo más alto es 'Luis Martinez' con un saldo de $12000

#16
def calcular_numero_triangular(n): #Funcion principal
    return n * (n + 1) // 2 #Calculo de número triangular.

n = int(input("Ingrese la cantidad de números triangulares a generar: ")) #Solicitar al usuario la cantidad de números triangulares a generar

print(f"Primeros {n} números triangulares:") #Calcular y imprimir los números triangulares

for i in range(1, n + 1): # nicia un bucle for que recorre desde 1 hasta n.
    numero_triangular = calcular_numero_triangular(i) #Calculatriangular para el valor i.
    print(numero_triangular, end=" ") #Imprime cada número triangular, separados por un espacio en lugar de un salto de línea.

#Ingrese la cantidad de números triangulares a generar: 1
#Primeros 1 números triangulares: 1

#17
def calcular_descuento(precio_original, porcentaje_descuento):
    if porcentaje_descuento < 0 or porcentaje_descuento > 100:
        raise ValueError("El porcentaje de descuento debe estar entre 0 y 100")

    descuento = precio_original * (porcentaje_descuento / 100)
    precio_final = precio_original - descuento
    return precio_final

# Ejemplo de uso
precio_original = 100
porcentaje_descuento = 20
precio_final = calcular_descuento(precio_original, porcentaje_descuento)
print(f"El precio final después del descuento es: ${precio_final}")

#El precio final después del descuento es: $80.0

#18
def numeros_pares(lista): #Definicion funcion
    pares = [numero for numero in lista if numero % 2 == 0] #Utiliza lista para crear una nueva lista llamada pares. La condición if numero % 2 == 0 verifica si el número es par.
    return pares #Devuelve valores pares

numeros = [1,2,3,4,5,6,7,8,9,10] #Dar lista
numeros_pares_resultado = numeros_pares(numeros) #Llama la funcion y guarda el resultado en la variable
print("Números pares:", numeros_pares_resultado) #Imprime lista final

#Números pares: [2, 4, 6, 8, 10]

#19
def encontrar_extremos(lista):
    if not lista:
        raise ValueError("La lista está vacía")

    maximo = float('-inf')  # Inicializar con un valor muy bajo
    minimo = float('inf')   # Inicializar con un valor muy alto

    for numero in lista:
        if numero > maximo:
            maximo = numero
        if numero < minimo:
            minimo = numero

    return maximo, minimo

# Ejemplo de uso
numeros = [15, 27, 8, 36, 12, 45, 6]

try:
    numero_mas_grande, numero_mas_pequeno = encontrar_extremos(numeros)
    print(f"El número más grande en la lista es: {numero_mas_grande}")
    print(f"El número más pequeño en la lista es: {numero_mas_pequeno}")
except ValueError as e:
    print(e)

#El número más grande en la lista es: 45
#El número más pequeño en la lista es: 6

#20
def generar_secuencia_pell(n): #Definicion de funcion principal
    if n == 0: #Comprueba si n es 0. Si sí, devuelve una lista vacía hay términos en la secuencia.
        return []
    if n == 1: #Comprueba si n es 1. Si sí, devuelve una lista con un único término, que es 0.
        return [0]

    secuencia = [0, 1] #Iniciar lista
    for i in range(2, n): #Inicia un bucle for desde 2 hasta n - 1.
        siguiente = 2 * secuencia[i - 1] + secuencia[i - 2] #Calcula el siguiente término de la secuencia utilizando la fórmula, donde P(n) es el término n de la secuencia.
        secuencia.append(siguiente) #Agrega el siguiente valor a la secuencia.

    return secuencia #Devuelve el resultado

n = int(input("Ingrese la cantidad de términos de la secuencia de Pell a generar: ")) #Solicitar al usuario la cantidad de términos a generar

secuencia_pell = generar_secuencia_pell(n) #Generar la secuencia de Pell

print("Secuencia de Pell con", n, "términos:") #Imprimir la secuencia generada
for term in secuencia_pell:
    print(term, end=" ") #separados por un espacio en lugar de un salto de línea.

#Ingrese la cantidad de términos de la secuencia de Pell a generar: 5
#Secuencia de Pell con 5 términos: 0 1 2 5 12

#21
def calcular_amortizacion(monto_prestamo, tasa_interes_anual, plazo_meses):
    tasa_interes_mensual = tasa_interes_anual / 12 / 100
    cuota_mensual = monto_prestamo * (tasa_interes_mensual * (1 + tasa_interes_mensual)**plazo_meses) / ((1 + tasa_interes_mensual)**plazo_meses - 1)

    print("Mes | Cuota Mensual | Capital | Interés | Saldo Restante")
    print("-" * 50)

    saldo_restante = monto_prestamo

    for mes in range(1, plazo_meses + 1):
        interes_mensual = saldo_restante * tasa_interes_mensual
        capital_mensual = cuota_mensual - interes_mensual
        saldo_restante -= capital_mensual

        print(f"{mes:3} | {cuota_mensual:13.2f} | {capital_mensual:7.2f} | {interes_mensual:6.2f} | {saldo_restante:14.2f}")

# Ejemplo de uso dentro de la función
calcular_amortizacion(10000, 8, 36)

#Mes | Cuota Mensual | Capital | Interés | Saldo Restante
#--------------------------------------------------
# 1 |        313.36 |  246.70 |  66.67 |        9753.30
# 2 |        313.36 |  248.34 |  65.02 |        9504.96
# 3 |        313.36 |  250.00 |  63.37 |        9254.96

#22
def es_numero_perfecto(numero): #Definir la funcion
    if numero <= 0: #Verifica si el número es menor o igual a 0. Si sí, devuelve False ya que no se consideran números perfectos negativos o cero.
        return False

    suma_divisores = 0 #Inicializa en 0 para acumular la suma
    for i in range(1, numero): #Inicia un bucle for que recorre desde 1 hasta n.
        if numero % i == 0: #Verifica si i es un divisor de numero.
            suma_divisores += i #Si i es un divisor de numero, se agrega i a la variable suma_divisores.

    return suma_divisores == numero #Función devuelve True si la suma de los divisores propios es igual al nUmero original, lo que indica que es numero perfecto.

numero = int(input("Ingrese un número para verificar si es perfecto: ")) #Solicitar al usuario ingresar un número

if es_numero_perfecto(numero): # Verificar si el número es perfecto utilizando la función
    print(numero, "es un número perfecto.")
else:
    print(numero, "no es un número perfecto.") #Sino es, indicar que no es un numero perfecto

#Ingrese un número para verificar si es perfecto: 28
#28 es un número perfecto.

#23
def mostrar_tasa_de_interes(tipo_prestamo):
    tasas_interes = {
        'personal': 10,
        'hipotecario': 6,
        'automotriz': 8,
        'educativo': 5,
        'tarjeta de crédito': 15
    }

    if tipo_prestamo in tasas_interes:
        tasa = tasas_interes[tipo_prestamo]
        print(f"La tasa de interés para un préstamo {tipo_prestamo} es: {tasa}%")
    else:
        print("Tipo de préstamo no encontrado")

tipo_prestamo = 'personal'
resultado = mostrar_tasa_de_interes(tipo_prestamo)
print(resultado)

tipo_prestamo = 'personal'
resultado = mostrar_tasa_de_interes(tipo_prestamo)
print(resultado)

#La tasa de interés para un préstamo personal es: 10%
#None
#La tasa de interés para un préstamo personal es: 10%
#None

#24
import numpy as np

def calcular_media_geometrica(lista_numeros): #Definicion de la funcion
    producto = np.prod(lista_numeros) #Da resultado el producto de la lista
    media_geometrica = producto ** (1 / len(lista_numeros)) #Operacion matematica
    return media_geometrica #Devuelve la media calculada

numeros = [2, 4, 8, 16] #Lista
media_geometrica = calcular_media_geometrica(numeros) #La media se calcula dado a la lista "numeros"
print("La media geométrica es:", media_geometrica) #Imprime resultado

#La media geométrica es: 5.656854249492381

#25
def segundo_numero_mas_grande(lista):
    if len(lista) < 2:
        return None

    maximo = max(lista)
    lista.remove(maximo)
    segundo_maximo = max(lista)
    return segundo_maximo

numeros = [15, 27, 8, 36, 12, 45, 6]
segundo_maximo = segundo_numero_mas_grande(numeros)
if segundo_maximo is not None:
    print(f"El segundo número más grande en la lista es: {segundo_maximo}")
else:
    print("La lista no tiene suficientes elementos.")

#El segundo número más grande en la lista es: 36

#26
def numeros_de_lucas(n): #Definir la funcion
    lucas = [2, 1] #Se empieza con los dos primeros numeros de la secuencia
    for _ in range(2, n): #Calcular los nmeros restantes
        lucas.append(lucas[-1] + lucas[-2]) #Calcula el siguiente numerosumando los dos últimos de la lista y los agrega.
    return lucas #Devuelve lista de numeros calculados

cantidad = int(input("Ingrese la cantidad de números de Lucas a calcular: ")) #Ingresar datos
resultados = numeros_de_lucas(cantidad) #Con los valores ingresados, se usa funcion

print(f"Los primeros {cantidad} números de Lucas son:") #Imprimir resultados
print(resultados)

#Ingrese la cantidad de números de Lucas a calcular: 100
#Los primeros 100 números de Lucas son:
#[2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199,...]

#27
def calcular_cuota_mensual(monto_prestamo, tasa_interes_anual, plazo_años):
    tasa_interes_mensual = tasa_interes_anual / 12 / 100
    plazo_meses = plazo_años * 12
    cuota_mensual = monto_prestamo * (tasa_interes_mensual * (1 + tasa_interes_mensual)**plazo_meses) / ((1 + tasa_interes_mensual)**plazo_meses - 1)

    print(f"La cuota mensual del préstamo es: ${cuota_mensual:.2f}")
calcular_cuota_mensual(20000, 4.5, 30)

#La cuota mensual del préstamo es: $101.34

#28
def es_numero_armstrong(numero): #Define la funcion
    num_str = str(numero)  #Convertir el número a una cadena de caracteres
    n = len(num_str)       #Obtener la cantidad de dígitos en el número
    suma_digitos = sum(int(digito) ** n for digito in num_str)  #Calcular la suma de dígitos elevados a n

    return numero == suma_digitos #Compara si el numero es igual a la suma de los dígitos elevados a n. Iguales=True, lo que indica que el número es un número de Armstrong; de lo contrario, devuelve Fals

numero = int(input("Ingrese un número: ")) #Solicita el numero a verificar
if es_numero_armstrong(numero): #Si el numero es numero armstrong, imprime que lo es
    print(numero, "es un número de Armstrong.")
else: #Sino, imprimirá lo contrario
    print(numero, "no es un número de Armstrong.")

#Ingrese un número: 100
#100 no es un número de Armstrong.

#29
def convertir_moneda(cantidad, moneda_origen, moneda_destino):
    tasas_cambio = {
        'USD': 0.85,  # 1 USD = 0.85 EUR
        'EUR': 1.18   # 1 EUR = 1.18 USD
    }

    if moneda_origen in tasas_cambio and moneda_destino in tasas_cambio:
        tasa = tasas_cambio[moneda_destino] / tasas_cambio[moneda_origen]
        cantidad_convertida = cantidad * tasa
        print(f"{cantidad:.2f} {moneda_origen} equivale a {cantidad_convertida:.2f} {moneda_destino}")
    else:
        print("Moneda no encontrada o conversión no admitida")
convertir_moneda(25, 'USD', 'EUR')

#25.00 USD equivale a 34.71 EUR

#30
import math #Importar libreria
def calcular_desviacion_estandar(lista_numeros): #Definicion de la funcion
    media = sum(lista_numeros) / len(lista_numeros) #Definicion de operacion matematica
    suma_cuadrados = sum((x - media) ** 2 for x in lista_numeros) #Calcular la suma de los cuadrados de las diferencias entre cada número y la media.
    desviacion_estandar = math.sqrt(suma_cuadrados / (len(lista_numeros) - 1)) #Calcular SD dividiendo la suma de los cuadrados por n - 1 (donde n es el tamaño de la lista) y luego tomando la raíz cuadrada.

    return desviacion_estandar #Devuelve el resultado

numeros = [10, 20, 30, 40, 50] #Lista de valores
desviacion = calcular_desviacion_estandar(numeros) #La funcion del calculo va acorde a los numeros dados
print("La desviación estándar es:", desviacion) #Imprime resultado

#La desviación estándar es: 15.811388300841896